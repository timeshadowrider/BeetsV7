from fastapi import APIRouter, HTTPException
from fastapi.responses import PlainTextResponse, FileResponse
from pathlib import Path
import subprocess
import threading
import json
import os
from urllib.parse import unquote

DATA_DIR = Path("/data")
MUSIC_DIR = Path("/music/library")
LOG_PIPELINE = DATA_DIR / "pipeline_verbose.log"
LOG_BEETS = DATA_DIR / "last_beets_imports.log"

# ---------------------------------------------------------
# UI ROUTER (prefix is applied in app.py)
# ---------------------------------------------------------
router = APIRouter(tags=["ui"])


# ---------------------------------------------------------
# Run pipeline (UI-triggered)
# ---------------------------------------------------------
def _run_pipeline():
    subprocess.run(["python3", "/app/scripts/pipeline_controller_v7.py"], check=False)


@router.post("/pipeline/run")
def run_pipeline():
    t = threading.Thread(target=_run_pipeline, daemon=True)
    t.start()
    return {"status": "started"}


# ---------------------------------------------------------
# Library Stats
# ---------------------------------------------------------
@router.get("/stats/library")
def get_library_stats():
    path = DATA_DIR / "stats.json"
    if not path.exists():
        raise HTTPException(404, "stats.json not found")
    return json.loads(path.read_text(encoding="utf-8"))


# ---------------------------------------------------------
# Inbox Stats
# ---------------------------------------------------------
@router.get("/stats/inbox")
def get_inbox_stats():
    inbox = Path("/inbox")
    artists = 0
    tracks = 0

    for artist_dir in inbox.iterdir():
        if not artist_dir.is_dir() or artist_dir.name == "failed_imports":
            continue

        artists += 1

        for root, dirs, files in os.walk(artist_dir):
            for f in files:
                if Path(f).suffix.lower() in {
                    ".flac", ".mp3", ".m4a", ".ogg", ".wav", ".aac"
                }:
                    tracks += 1

    return {"artists": artists, "tracks": tracks}


# ---------------------------------------------------------
# Recent Albums
# ---------------------------------------------------------
@router.get("/albums/recent")
def get_recent_albums():
    path = DATA_DIR / "recent_albums.json"
    if not path.exists():
        raise HTTPException(404, "recent_albums.json not found")

    data = json.loads(path.read_text(encoding="utf-8"))
    return sorted(
        data,
        key=lambda a: a.get("added", a.get("mtime", "")),
        reverse=True
    )


# ---------------------------------------------------------
# All Albums (for search + webplayer)
# ---------------------------------------------------------
@router.get("/albums/all")
def get_all_albums():
    path = DATA_DIR / "albums.json"
    if not path.exists():
        raise HTTPException(404, "albums.json not found")
    return json.loads(path.read_text(encoding="utf-8"))


# ---------------------------------------------------------
# Cover Art Endpoint (NEW)
# ---------------------------------------------------------
@router.get("/library/cover/{artist}/{album}")
def get_cover(artist: str, album: str):
    """
    Serve cover.jpg for a given artist + album.
    This matches the JSON paths generated by generate_ui_json().
    """
    artist = unquote(artist)
    album = unquote(album)

    cover_path = MUSIC_DIR / artist / album / "cover.jpg"

    if not cover_path.exists():
        raise HTTPException(404, "Cover not found")

    return FileResponse(str(cover_path), media_type="image/jpeg")


# ---------------------------------------------------------
# Logs
# ---------------------------------------------------------
@router.get("/logs/pipeline", response_class=PlainTextResponse)
def get_pipeline_log():
    if not LOG_PIPELINE.exists():
        raise HTTPException(404, "pipeline log not found")
    return LOG_PIPELINE.read_text(encoding="utf-8")


@router.get("/logs/beets", response_class=PlainTextResponse)
def get_beets_log():
    if not LOG_BEETS.exists():
        raise HTTPException(404, "beets log not found")
    return LOG_BEETS.read_text(encoding="utf-8")

# ---------------------------------------------------------
# Stats
# ---------------------------------------------------------


@router.get("/stats")
def get_global_stats():
    """
    Full library analytics for the UI dashboard.
    Pulls from albums.json and computes:
    - file type counts
    - codec counts
    - bit depth distribution
    - sample rate distribution
    - genre distribution
    - year distribution
    - total tracks, albums, artists
    """
    albums_path = DATA_DIR / "albums.json"
    if not albums_path.exists():
        raise HTTPException(404, "albums.json not found")

    data = json.loads(albums_path.read_text(encoding="utf-8"))

    formats = {}
    bit_depths = {}
    sample_rates = {}
    genres = {}
    years = {}

    total_tracks = 0
    artists = set()
    album_artists = set()

    for album in data:
        artists.add(album.get("albumartist"))
        album_artists.add(album.get("albumartist"))
        total_tracks += len(album.get("tracks", []))

        for t in album.get("tracks", []):
            # codec / file type
            codec = (t.get("codec") or "").lower()
            formats[codec] = formats.get(codec, 0) + 1

            # bit depth
            bd = t.get("bit_depth")
            if bd:
                bit_depths[str(bd)] = bit_depths.get(str(bd), 0) + 1

            # sample rate
            sr = t.get("sample_rate")
            if sr:
                sample_rates[str(sr)] = sample_rates.get(str(sr), 0) + 1

            # genre
            g = t.get("genre")
            if g:
                genres[g] = genres.get(g, 0) + 1

            # year
            y = t.get("year")
            if y:
                years[str(y)] = years.get(str(y), 0) + 1

    return {
        "library": {
            "albums": len(data),
            "tracks": total_tracks,
            "artists": len(artists),
            "album_artists": len(album_artists),
        },
        "formats": formats,
        "bit_depths": bit_depths,
        "sample_rates": sample_rates,
        "genres": genres,
        "years": years,
    }

